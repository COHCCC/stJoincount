---
title: "Introduction to stJoincount"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to stJoincount}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r set up, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE, warning=FALSE}
library(stJoincount)
library(BiocFileCache)
#library(rhdf5)
library(hdf5r)
library(spdep)
library(raster)
library(Seurat)
library(reshape2)
library(pheatmap)
```

v0.99.3

stJoincount: A tool to determine spatial correlations in labeled and mapped spatial transciptomics data using join count statistics.  

This tool is compatible with data produced with the 10X Genomics Visium Spatial Gene Expression platform, in which each spatial barcode has been assigned a categorical label. Examples of appropriate labels are cluster assignment, cell identity annotation, neighborhood assignment, cell cycle phase, etc. 

The purpose of this R package is to quantify spatial correlation in an arrangement of spatially contiguous nominal data. The spatial and label information from the sample is first converted into a raster format. Join count analysis is then applied to determine spatial dependencies of all possible label pairs present in the sample.  

In this vignette, we will apply join count analysis to a human breast cancer spatial transcriptomics sample generated by 10x Genomics. The data can be downloaded using the code below or by navigating to the website [here](https://www.10xgenomics.com/resources/datasets/human-breast-cancer-block-a-section-1-1-standard-1-1-0)
```{r, message = FALSE, warning=FALSE}

bfc <- BiocFileCache::BiocFileCache()
bc.url <-
  paste0(
    "https://cf.10xgenomics.com/samples/spatial-exp/",
    "1.1.0/V1_Breast_Cancer_Block_A_Section_1/",
    c(
      "V1_Breast_Cancer_Block_A_Section_1_filtered_feature_bc_matrix.tar.gz",
      "V1_Breast_Cancer_Block_A_Section_1_spatial.tar.gz",
      "V1_Breast_Cancer_Block_A_Section_1_analysis.tar.gz"
    )
  )


h5.url <-
  paste0(
    "https://cf.10xgenomics.com/samples/spatial-exp/",
    "1.1.0/V1_Breast_Cancer_Block_A_Section_1/",
    "V1_Breast_Cancer_Block_A_Section_1_filtered_feature_bc_matrix.h5"
  )

outDir = file.path(tempdir(), "outs")
bc.data <- sapply(bc.url, BiocFileCache::bfcrpath, x = bfc)
sapply(bc.data, utils::untar, exdir = file.path(tempdir(), "outs"))
download.file(h5.url, destfile = paste0(outDir, "/filtered_feature_bc_matrix.h5"), method="auto")
#list.files(outDir)
```

1. This package requires data that has been pre-processed through the 10x Genomics spaceranger pipelines, which produce a directory containing a H5 file specified by filename, image data in a subdirectory called spatial, and analysis results in a subdirectory called analysis. `spatialDataPrep()` is a function to load a pre-processed 10x Genomics Visium Spatial Experiment into a Seurat object.  The input for `spatialDataPrep()` is the spaceranger output directory described above. `spatialDataPrep()` also applies the result of spaceranger's graph-based clustering (provided in `./analysis/clustering/graphclust`) to the Seurat object's metadata under the heading "Cluster". In this example, we will be looking for spatial dependencies between clusters. 
```{r, warnings = FALSE}
sample <- spatialDataPrep(outDir)
# The name of .h5 file must match to the name of filtered_feature_bc_matrix
```
* Note: User can also annotate the data with custom labels. The package will analyze data found in `sample$Cluster`, so custom labels should be added to the metadata under the name "Cluster". Currently, the package only accepts integer labels ("1, 2, 3, etc..."). We recommend that users convert categorical labels into an integer format, and keep a key of corresponding assignments. 

2. The labeled spatial data can now be converted into a raster format, in which each spatial feature is represented by a pixel. `rasterizeEachCluster()` will perform a rasterization of the sample, which includes calculation of optimal resolution and extent, and unique coding of each label in the resulting raster. 

```{r, warnings = FALSE}
mosaicIntegration <- rasterizeEachCluster(sample)
```
The function results in a raster in which pixels are coded with 1, 2, 3, etc, corresponding to clusters 1, 2, 3, etc.

3. `mosaicIntPlot()` can be used to visualize the raster produced in step 2. 
```{r, fig.dim = c(6, 6)}
mosaicIntPlot(mosaicIntegration)
```

4. The rasterized sample is now compatible with join count analysis (JCA). `joincountAnalysis()` is a function that performs JCA on the output of `rasterizeEachCluster()`. The analysis tabulates the observed joins between all possible label pairings, and calculates the results expected under conditions of spatial randomness. The results returned also include the variance of observed to expected calculated under non-free sampling, as well as the z-score. 
```{r, warnings = FALSE}
joincount.result <- joincountAnalysis(mosaicIntegration)
```
Clustering can be interpreted as an observed join count that is greater than what would be expected in a random arrangement, and will be reflected in a positive z-score. Conversely, dispersion will result in fewer joins that in a random arrangement, resulting in a negative z-score. 

5. z-scores resulting from JCA lend themselves well to visualization in a heatmap. `zscoreMatrix()` can be used to compile z-scores into a datafame, which can then be used with `zscorePlot()` to produce the heatmap. 
```{r, warnings = FALSE}
matrix <- zscoreMatrix(sample, joincount.result)
```

```{r, fig.dim = c(6, 6)}
zscorePlot(matrix)
```

```{r}
sessionInfo()
```
